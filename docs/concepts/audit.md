# Audit System

The audit system provides observability into agent execution by emitting structured events at key points during
operation. These events enable logging, debugging, compliance recording, and metrics collection without modifying the
core agent logic.

## Why Audit Matters

When Claude operates as an autonomous agent executing tools and making decisions, visibility into its actions becomes
critical for:

1. **Debugging** - Understanding why an agent took specific actions
2. **Compliance** - Recording actions for regulatory or policy requirements
3. **Cost Tracking** - Monitoring API usage and associated costs
4. **Performance Analysis** - Identifying bottlenecks and optimization opportunities
5. **Security Review** - Detecting unexpected or unauthorized operations

The audit system captures this information in a structured format suitable for automated processing.

### Healthcare Domain Example

A clinical decision support system requires audit trails for:

- Every query made to patient records
- Recommendations generated by the agent
- Tools invoked and their results
- Total cost per session for billing allocation

The audit system provides this data without instrumenting the application code.

## Configuring Audit Handlers

The `Audit` option registers a handler function that receives events:

```go
a, err := agent.New(ctx,
    agent.Model("claude-sonnet-4-5"),
    agent.Audit(func(e agent.AuditEvent) {
        log.Printf("[%s] Session %s: %v", e.Type, e.SessionID, e.Data)
    }),
)
```

Multiple handlers can be registered by calling `Audit` multiple times:

```go
a, err := agent.New(ctx,
    agent.Model("claude-sonnet-4-5"),
    agent.Audit(logHandler),
    agent.Audit(metricsHandler),
    agent.Audit(securityHandler),
)
```

All handlers receive every event. Handler failures do not affect other handlers or agent operation.

## File-Based Audit Logging

The `AuditToFile` option writes events to a JSONL (JSON Lines) file:

```go
a, err := agent.New(ctx,
    agent.Model("claude-sonnet-4-5"),
    agent.AuditToFile("audit.jsonl"),
)
if err != nil {
    log.Fatal(err)
}
defer a.Close()  // Closes the audit file
```

Each line in the file contains a complete JSON object representing one event. This format supports efficient streaming
processing with tools like `jq`:

```bash
# Count events by type
cat audit.jsonl | jq -r '.type' | sort | uniq -c

# Find all tool invocations
cat audit.jsonl | jq 'select(.type == "tool.use")'

# Sum total cost
cat audit.jsonl | jq 'select(.type == "session.end") | .data.cost_usd' | paste -sd+ | bc
```

## AuditEvent Structure

Every event shares a common structure:

```go
type AuditEvent struct {
    Time      time.Time `json:"time"`       // When the event occurred
    SessionID string    `json:"session_id"` // Session identifier
    Type      string    `json:"type"`       // Event type
    Data      any       `json:"data,omitempty"` // Event-specific data
}
```

The `Data` field varies by event type.

## Event Types

The audit system emits events at key lifecycle points:

| Event Type          | When Emitted               | Data Contents                  |
|---------------------|----------------------------|--------------------------------|
| `session.start`     | Agent begins a new session | Model, configuration           |
| `session.end`       | Agent session completes    | Total turns, cost, reason      |
| `message.user`      | User prompt submitted      | Prompt text                    |
| `message.assistant` | Claude responds            | Response content               |
| `tool.use`          | Tool invocation begins     | Tool name, inputs              |
| `tool.result`       | Tool execution completes   | Result, duration, error status |
| `hook.pre_tool_use` | PreToolUse hook evaluated  | Decision, reason               |
| `error`             | Error occurs               | Error details                  |

### Example Event Sequence

A typical Run() call generates events in this order:

```json
{"time":"2024-01-15T10:30:00Z","session_id":"abc123","type":"message.user","data":{"prompt":"List Go files"}}
{"time":"2024-01-15T10:30:01Z","session_id":"abc123","type":"tool.use","data":{"name":"Glob","input":{"pattern":"**/*.go"}}}
{"time":"2024-01-15T10:30:01Z","session_id":"abc123","type":"hook.pre_tool_use","data":{"tool":"Glob","decision":"allow"}}
{"time":"2024-01-15T10:30:02Z","session_id":"abc123","type":"tool.result","data":{"tool_use_id":"tu_1","duration_ms":45}}
{"time":"2024-01-15T10:30:03Z","session_id":"abc123","type":"message.assistant","data":{"text":"Found 12 Go files..."}}
```

## Custom Audit Handlers

### Writer-Based Handler

The `AuditWriterHandler` creates a handler that writes to any `io.Writer`:

```go
handler := agent.AuditWriterHandler(os.Stdout)

a, err := agent.New(ctx,
    agent.Model("claude-sonnet-4-5"),
    agent.Audit(handler),
)
```

Use this to write to custom destinations like network connections or buffers.

### File Handler with Cleanup

The `AuditFileHandler` returns a handler and a cleanup function:

```go
handler, cleanup, err := agent.AuditFileHandler("audit.jsonl")
if err != nil {
    log.Fatal(err)
}
defer cleanup()  // Closes the file

a, err := agent.New(ctx,
    agent.Model("claude-sonnet-4-5"),
    agent.Audit(handler),
)
```

This provides explicit control over file lifecycle.

### Filtering Handler

Create handlers that process specific event types:

```go
costTracker := func(e agent.AuditEvent) {
    if e.Type != "session.end" {
        return
    }
    data, ok := e.Data.(map[string]any)
    if !ok {
        return
    }
    if cost, ok := data["cost_usd"].(float64); ok {
        metrics.RecordCost(e.SessionID, cost)
    }
}

a, err := agent.New(ctx,
    agent.Model("claude-sonnet-4-5"),
    agent.Audit(costTracker),
)
```

### Async Handler

For handlers that perform slow operations, use a channel to avoid blocking:

```go
eventChan := make(chan agent.AuditEvent, 100)

go func() {
    for e := range eventChan {
        // Slow operation: write to remote database
        db.Insert(e)
    }
}()

asyncHandler := func(e agent.AuditEvent) {
    select {
    case eventChan <- e:
    default:
        log.Println("audit channel full, dropping event")
    }
}

a, err := agent.New(ctx,
    agent.Model("claude-sonnet-4-5"),
    agent.Audit(asyncHandler),
)
```

## Analysis Patterns

### Session Cost Report

```go
type SessionCost struct {
    SessionID string
    TotalCost float64
    Turns     int
}

func analyzeCosts(events []agent.AuditEvent) []SessionCost {
    costs := make(map[string]*SessionCost)

    for _, e := range events {
        if e.Type == "session.end" {
            data := e.Data.(map[string]any)
            costs[e.SessionID] = &SessionCost{
                SessionID: e.SessionID,
                TotalCost: data["cost_usd"].(float64),
                Turns:     int(data["turns"].(float64)),
            }
        }
    }

    result := make([]SessionCost, 0, len(costs))
    for _, c := range costs {
        result = append(result, *c)
    }
    return result
}
```

### Tool Usage Statistics

```go
func toolStats(events []agent.AuditEvent) map[string]int {
    counts := make(map[string]int)

    for _, e := range events {
        if e.Type == "tool.use" {
            data := e.Data.(map[string]any)
            toolName := data["name"].(string)
            counts[toolName]++
        }
    }

    return counts
}
```

### Error Rate Calculation

```go
func errorRate(events []agent.AuditEvent) float64 {
    var total, errors int

    for _, e := range events {
        if e.Type == "tool.result" {
            total++
            data := e.Data.(map[string]any)
            if isErr, ok := data["is_error"].(bool); ok && isErr {
                errors++
            }
        }
    }

    if total == 0 {
        return 0
    }
    return float64(errors) / float64(total)
}
```

## Handler Error Handling

The audit system recovers from panics in handlers:

```go
unreliableHandler := func(e agent.AuditEvent) {
    // If this panics, other handlers still receive events
    panic("handler crashed")
}

a, err := agent.New(ctx,
    agent.Model("claude-sonnet-4-5"),
    agent.Audit(unreliableHandler),
    agent.Audit(reliableHandler),  // Still receives events
)
```

One failing handler does not affect others or the agent.

## Use Cases

### Compliance Logging

```go
agent.Audit(func(e agent.AuditEvent) {
    // Write to immutable audit log
    complianceLog.Append(e)
})
```

### Real-Time Monitoring

```go
agent.Audit(func(e agent.AuditEvent) {
    // Stream to monitoring dashboard
    metrics.Emit(e.Type, e.SessionID, e.Data)
})
```

### Debug Tracing

```go
agent.Audit(func(e agent.AuditEvent) {
    if debugMode {
        fmt.Printf("[DEBUG] %s: %s %+v\n", e.Time.Format(time.RFC3339), e.Type, e.Data)
    }
})
```

## Limitations

- Handlers are called synchronously; slow handlers delay agent execution
- Events are not persisted if no handler is configured
- Handler panics are silently recovered; no notification mechanism exists
- Event data structures may vary; defensive type assertions are recommended
